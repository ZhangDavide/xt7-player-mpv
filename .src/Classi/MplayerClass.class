' Gambas class file

'Copyright (C) 2007, 2008 Antonio Orefice
' Gambas class file

'http://www.mplayerhq.hu/DOCS/tech/slave.txt


'Public Audiofilter As String = "*.mp3;*.ogg;*.aac;*.flac;*.mpc;*.ac3;"
Public wantlog As Boolean = True
Public IsNetworkURI As Boolean = False

Public stdout As String
Public stderr As String
Public modules_out As String

Private Playerprocess As Process
Private RenicerProcess As Process

Private Const play_initialized_str As String = "MPV_PLAY_IS_FULLY_INITIALIZED"


Private stopping As Boolean = False

Public pausing As Boolean = False
Public return_value As Integer = 0 'playerprocess return value

' Private Takingscreenshot As Boolean = False
'Private lastscreenshot As String = ""
Public last_media As String = ""

Public commandline As String = ""

Private InputPipe As String = ""

Public user_stopped As Boolean = False


Public Function executable(Optional timeout As Integer = -1) As String
  Dim out As String
  Dim proxy As String
  
  out &= out & GeneralOptions.MplayerEnvVars.text & " " 'user specified environment variables
  If GeneralOptions.vdpauooverlaycheck.value = True Then
    out &= " " & "VDPAU_NVIDIA_NO_OVERLAY=1" & " "
  Endif

  out &= "LC_ALL=C "
  proxy = global.proxyfromenv()
  If proxy <> "" Then out &= "http_proxy=" & proxy & " "
  
  If timeout <> -1 Then 
     out &= "timeout -s 9 " & timeout & " "
  Endif

  out &= GeneralOptions.MplayerExeText.Text & " "
  Return out
End

Public Precommand As String = ""
Public Postcommand As String = ""

Public CurrentOptions As String = ""

Public AVcodecs As String = ""

Public AudioLanguages As String = "\"\""
Public SubLanguages As String = "\"\""
Public Subfile As String = ""
Public Quick As Boolean = False                         'Skip mediainfo code



Private Sub ClearMediaProperties()

  prop = New Collection
  prop.Clear
  prop_time = New Collection
  prop_time.clear
  ' setP("time-pos", 0)
  ' setP("Length", 0)
  ' setP("audio-channels", 0)
  ' setP("Height", 0)
  ' setP("width", 0)
  ' setP("trackno", 0)
  ' setP("percent_pos", 0)
  prop["audioonly"] = False
  prop["size"] = 0
  prop["audiotracks"] = New String[] 
  prop["subtitletracks"] = New String[] 
  prop["cddbtracks"] = New String[] 
End


'Realtime Media variables


Public osdlevel As String = ""



Public Function FillMultitracks(Optional force_audio_only As Boolean = False)
  Dim T, Tcount As Integer
  Dim Type As String
  Dim id, name, lang, tmp, codec As String
  Dim properties As New String[]
  Dim video_ok As Boolean = False
  Dim t0 As Float
  Dim timeout As Integer = 1 'seconds
  Dim videotracks As Integer = 0

  If getP("fullpath") = "" Then Return
  
  Try prop["audiotracks"].Clear
  Try prop["subtitletracks"].Clear
  Try Tcount = CInt(get_property_mpv("track-list/count"))
  ' If Tcount = 0 Then
  '   '0 tracks is unlikely; probably mpv is not answering correctly
  '   'keep asking till the timeout or a real answer
  '   t0 = Timer()
  '   Repeat
  '     global.myDebug("0 tracks is unlikely, reasking")
  '     Wait 0.01
  '     Try Tcount = CInt(get_property_mpv("track-list/count"))
  '   Until Tcount <> 0 Or (Timer() - t0) > timeout
  ' Endif

  If Error Then
    global.myDebug("WW", "unable to get track count")
    Return
  Endif

  For T = 0 To Tcount - 1
    properties.add("track-list/" & T & "/id")
    properties.add("track-list/" & T & "/title")
    properties.add("track-list/" & T & "/lang")
    properties.add("track-list/" & T & "/type")
    properties.add("track-list/" & T & "/codec")
  Next 'T
  
  properties.Add("vo-configured")
  properties.Add("current-vo")
  
  get_properties_mpv(properties)
  

  For T = 0 To Tcount - 1
    id = getP("track-list/" & T & "/id") 
    name = getP("track-list/" & T & "/title") 
    lang = getP("track-list/" & T & "/lang") 
    Type = getP("track-list/" & T & "/type") 
    codec = getP("track-list/" & T & "/codec") 
    tmp = (ID & " - " & NAME & " - " & LANG & " - " & CODEC)
    Select Case Type
      Case "audio"
        prop["audiotracks"].Add(Replace(tmp, unavailable_str, "*"))
      ' Case "video"
        'multiple video tracks unsupported by xt7
      Case "sub"
        prop["subtitletracks"].Add(Replace(tmp, unavailable_str, "*"))
      Case "video"
        videotracks += 1
    End Select
  Next

  video_ok = getP("vo-configured") = "yes"
  video_ok = video_ok And (getP("current-vo") <> "(unavailable)")

  If (Not video_ok) And (videotracks > 0) Then 'something is not right...
    If idleplaying Then
      t0 = Timer()
      Repeat
        Wait 0.01
        video_ok = getP("vo-configured") = "yes"
        video_ok = video_ok And (getP("current-vo") <> "(unavailable)")
      Until video_ok Or (Timer() - t0) > timeout
      If (Timer() - t0) > timeout Then
        global.myDebug("?? video_ok is false but there are video tracks ??")
        'at least we tried.
        'since we are in idleplaying, there is no need to wait for vo-configured and current-vo.
      Endif
    Endif
  Endif
  If Not force_audio_only Then
    If idleplaying Then
      setP("audioonly", (videotracks = 0))
        Else
      setP("audioonly", (Not video_ok))
    Endif
      Else
    setP("audioonly", True)
  Endif
  ' If global.IsVideoFile(getP("fullpath")) And (Not video_ok) Then Stop
  ' If getP("audioonly") = True Then Stop
End

Public Function get_length() As String
  Return get_property_mpv("=duration")
End


Public Sub Renice(nice As Integer, Optional JustThePlayer As Boolean = False)
  global.myDebug("nice=" & nice)
  
  If (Not JustThePlayer) Then RenicerProcess = Shell "renice " & nice & " -p " & Application.id  'renice the whole application to 'nice'
  RenicerProcess = Shell "renice " & (nice - 1) & " -p " & playerprocess.id 
End


Private Function MidC(s As String, a As String, Optional b As String) As String
  'return the first occurrence of the string between a and b
  'if b is omitted then all the string starting from a is returned
  Dim mmid As String
  mMid = Mid(s, InStr(s, a) + Len(a))
  If b <> "" Then 
    Return Left(mmid, InStr(mmid, b) - 1)
      Else
    Return mMid
  Endif
End

Public Sub playerprocess_read(Optional injected As String = "")
  Dim sBufs, sBuf As String
  Dim question, answer As String
  Try Read #playerprocess, sBufs, -4096

  For Each sBuf In Split(sbufs, "\n", "", True)
    If sBuf Like "*ANS_*|*" Then
      question = MidC(sBuf, "_", "|")
      answer = (MidC(sBuf, "|"))
      Try prop.Remove(question)
      setP(question, answer)
      setP_time(question, Timer())
        Else If sbuf Like "\\[*\\] *" Then
          'filter some noisy ladspa plugins
          If Not (sbuf Like "*Parsed_ladspa_*") Then 
            modules_out &= sBuf & "\n"
          Endif
        Else
        stdout &= sBuf & "\n"
    Endif
  Next 'sbuf
End

Public Sub playerprocess_error(err As String)
  'global.mydebug(err)
  stderr &= err & "\n"
  If err Like "*" & play_initialized_str & "*" Then 
    'catch statusline with the message player initialized
    'this hopefully means the play is initialized
    set_property_mpv("options/term-status-msg", "")
    setP("play_initialized", "yes")
  Endif
End



'######################### Player controls section


Public Function SupportsLadspa() As Boolean
  Dim out As String
  Exec ["sh", "-c", "ffmpeg -filters | grep ladspa"] To out
  Return Trim(out) <> ""
End







Public Function dvb_set_channel(channelname As String, dvbcardID As Integer) As Boolean 'fixmempv is stub
  ' Dim channelN As String
  ' 
  ' ChannelN = DvbChannelToNumber(channelname)
  ' Send("dvb_set_channel " & ChannelN & " " & dvbcardID)
  ' Wait 0.01
  ' Send("dvb_set_channel " & ChannelN & " " & dvbcardID)
  ' Wait 0.01
  ' Send("dvb_set_channel " & ChannelN & " " & dvbcardID)
  ' 
  ' CurrentCache = "0"
  ' ClearMediaHeaders()
  ' GotHeaders = False
  ' LastSplittedOutput = ""
  ' Media_FullPath_Playing = ""
  ' Audioonly = False
  ' WaitForHeaders()
  ' GetAllTags()
  ' 
  ' Media_FullPath_Playing = "dvb://" & channelname
  ' Media_FullPath = "dvb://" & channelname
  ' 
  ' 
  ' 
  '     'here we may need to send the last volume (variable=lastvolume) to the running mplayer
  '     'because it seems it resets the volume after each channel change
  '     'the problem is that maybe we need to send it delayed..eg: after the channel as been tuned?
  ' 
  ' Return True
End

Public Function dvb_channel_to_number(C As String) As Integer
  Dim i As Integer
  Dim chans As String[]
  Dim chansfix As New String[]
  Dim chanfile As String = User.home & "/.config/mpv/channels.conf.ter"
  If Not (Exist(chanfile)) Then Return 0
  
  chans = Split(file.Load(chanfile), "\n")
  For i = 0 To chans.Max 'we have to discard any non valid channel line, because so does mplayer
    If Split(chans[i], ":").count = 13 Then chansfix.Add(chans[i])
  Next
  
  For i = 0 To chansfix.Max
    If Trim(chansfix[i]) <> "" Then
      If Lower(Split(chansfix[i], ":")[0]) = Lower(C) Then 
        Return i
      Endif
    Endif
  Next
  Return 0
End


Public mpvoptions As New Collection

Public Sub set_option(name As String, data As String, Optional allow_dupes As Boolean = True)
 'chr(8) is used instead of null because the collection doesn't keep null values
  If allow_dupes Then
    While mpvoptions.Exist(name)
      name = " " & name 'prefix white spaces to use multiple options with the same name
    Wend
  Endif
  mpvOptions[name] = data
  global.myDebug(name, data)
End

Public Sub unset_option(name As String, Optional options As Collection = mpvoptions)
  Dim tName As String = name
  While options.Exist(tName)
    options.Remove(tName)
    tName = " " & tName 'prefix white spaces to use multiple options with the same name
    global.myDebug(tName)
  Wend
End

Private Function set_options() As String
  Dim data, out As String
  For Each data In mpvoptions
    If data <> Chr(8) Then 'chr(8) is used instead of null because the collection doesn't keep null values
      out &= "--" & Trim(mpvoptions.Key) & "=" & data & " " 'trim is needed because we use white spaces to have multiple options with the same name
      global.myDebug("Add option:", mpvoptions.Key, "=", data)
        Else
      out &= "--" & mpvoptions.Key & " "
      global.myDebug("Add option:", mpvoptions.Key)
    Endif
    next_opt:
  Next
  Return out  
End


Private Function fix_options(Optional broken_opts As Collection = mpvoptions) As Collection
  Dim return_opts As Collection = broken_opts.Copy()
  Dim data As String
  'handle corner cases where an option could conflict with another
  For Each data In return_opts
    If data Like "*lavcac3enc*" Then 'unset audio-channels when encoding ac3 streams
      If return_opts.Key Like "*af*" Then
        Print "found audio filter lavcac3enc; searching and unsetting --audio-channels"
        Print
        unset_option("audio-channels", return_opts)
      Endif
        Else If return_opts.Key = "vo" Then
          If data Like "*opengl:*interpolation*" Then
            Print "It seems that user requested opengl temporal interpolation; setting --video-sync=display-vdrop" 
            set_option("video-sync", "display-vdrop")
          Endif
    Endif
  Next
  Return return_opts
End


Public Function get_option(name As String) As String
  Try Return mpvoptions[name]
  If Error Then Return Null
End


Public Sub clear_options()
  mpvoptions = New Collection
End

Public Function waitplayback(timeoutcentisecs As Integer) As Boolean
  Dim play_initialized As Boolean = False
  Dim idling As Boolean
  Dim tc As Integer = 0
  Dim waittime As Float = 0.01
  setP("idle", "no")

  Repeat
    If Not ProcessRunningOvr() Then Return False
    Wait waittime
    timeoutcentisecs -= CInt(waittime * 100)
    If IsInteger(CStr(timeoutcentisecs / 100)) Then 'check if playback is idle (eg: no file playing) every second
      global.myDebug("check if idle")
      get_property_mpv("=idle", False)
    Endif
    play_initialized = (getP("play_initialized") = "yes")
    'play_initialized is set by playerprocess_error through the hack
    'of setting the statusline to a value recognized by playerprocess_error
    'Hopefully, when the statusline is initialized, the playback is initialized too.
    'In case of problems, the core-idle property may come handy (but slower), see:
    'https://github.com/mpv-player/mpv/commit/8d414e2fe7f79f1bbf9158e8aa034e9ac9cf2222#commitcomment-13950548
    
    '...however sometimes the track count is still 0, so use track-list/count too.
    Try tc = get_property_mpv("track-list/count", True, 10, False)
    play_initialized = play_initialized And (tc <> 0)
    waittime += 0.01
    If waittime >= 0.2 Then waittime = 0.2
  Until play_initialized Or (timeoutcentisecs <= 0) Or (getP("=idle") = "yes")
  global.myDebug("timeoutcentisecs=", timeoutcentisecs)
  global.myDebug("play_initialized=", play_initialized)
  global.myDebug("getp_idle=", getP("=idle"))
  global.myDebug("track-list/count=", getP("track-list/count"))
  If play_initialized Then
    setP("idle", Null)
    Return True
  Endif
  setP("idle", Null)
  Return False
End


' Public Function waitplayback(timeoutcentisecs As Integer) As Boolean
'   Dim cTime As Float = 0
'   Dim idling As Boolean
'   setP("idle", "no")
' 
'   Repeat
'     If Not ProcessRunningOvr() Then Return False
'     get_property_mpv("=time-pos", False)
'     Wait 0.01
'     timeoutcentisecs -= 1
'     Try cTime = getP("=time-pos")
'     If IsInteger(CStr(timeoutcentisecs / 100)) Then 'check if playback is idle (eg: no file playing) every second
'       get_property_mpv("=idle", False)
'     Endif
'   Until (cTime > 0) Or (timeoutcentisecs <= 0) Or (getP("=idle") = "yes")
'   If ctime > 0 Then 
'     setP("=time-pos", Null)
'     setP("idle", Null)
'     Return True
'   Endif
'   setP("idle", Null)
'   Return False
' End

' Public Function waitplayback(timeoutcentisecs As Integer) As Boolean
'   Dim i As Integer
'   Dim cTime As Float = 0
'   For i = 1 To (timeoutcentisecs Div 100)
'     Try cTime = (get_property_mpv("=time-pos", True, "100"))
'     While (ctime = 0) And ProcessRunningOvr()
'       Try cTime = (get_property_mpv("=time-pos", True, "100"))
'       Wait
'     Wend
'     If ctime > 0 Then 
'       setP("=time-pos", Null)
'       Return True
'     Endif
'   Next
'   Return False
' End


Private prop As Collection
Private prop_time As Collection

Public Sub setP(aKey As String, aData As Variant)
  'set property into a collection in lowercase
  Try prop[Lower(aKey)] = aData
  If Error Then global.myDebug("Error while trying to set: ", aKey, "=", aData)
End

Private Sub setP_time(aKey As String, timestamp As Float)
  'set property into a collection in lowercase
  Try prop_time[Lower(aKey)] = timestamp
  If Error Then global.myDebug("Error while trying to set: ", aKey, "=", timestamp)
End

Private Function getP_time(aKey As String) As Float
  Try Return prop_time[akey]
  If Error Then Return -1
End



Public Function getP(aKey As String, Optional unanswered_string As String) As Variant
  'get a lowercase property from a key
  'if the key is not found, then return null, or return unanswered_string if specified.
  If prop.exist(Lower(aKey)) Then Return prop[Lower(aKey)]
  If unanswered_string <> Null Then 
    Return unanswered_string
      Else
    Return Null
  Endif
End

Public event_loop As Timer


Public watched_properties As New String[]
Public watched_properties_old_data As New String[]

Public Sub event_loop_timer()
  '* generate events on property changes 
  '* keep properties updated
  Dim name, data_new, data_old As String
  Dim i As Integer
  If watched_properties.count > 0 Then
    get_properties_mpv(watched_properties, False) 'async ask for those properties
    Wait 0.1
    'see if some property has changed:

    For i = 0 To watched_properties.count - 1

      name = watched_properties[i]
      data_new = getP(name)
      data_old = watched_properties_old_data[i]

      If data_old <> data_new Then 
        Raise property_change(name, data_old, data_new)
        watched_properties_old_data[i] = data_new
      Endif
    Next
  Endif


End

Event property_change(name As String, data_old As String, data_new As String)

Event seeking()

Private Function internal_options() As Collection
  Dim out As New Collection

  'Returns a collection Of options that will be set every Time, depsite any configuration option

  'out["quiet"] = "yes"
  out["input-file"] = SetUpInputPipe()
  out["msg-color"] = "no"
  out["msg-level"] = "all=v,cplayer=status,dvdnav=no,disc=no"
  out["input-default-bindings"] = "no"
  out["term-status-msg"] = play_initialized_str
  out["force-seekable"] = "yes" 'this will allow seeks within the cache

  'this array will be needed by do_apply().
  'because it decides if a restart is needed by comparing the changed user options
  'with the previous one. But since changed options are set from the outside,
  'which has no clue about those internal_options, we say to do_apply to ignore
  'the following:
  ignore_opts = ["input-file", "term-status-msg", "msg-color", "msg-level", "input-default-bindings", "start", "force-seekable", "volume"]
  Return out
End





Public Function do_play(filename As String, Optional string_options As String = "", Optional restart As Boolean = False, Optional bugid1870 As Boolean = False, Optional cookieopts As String = "", Optional dumpfile As String = "/tmp/stream.dump.xt7.mpeg", Optional doanalyze As Boolean = False) As Boolean
  Dim killer_script As String = Temp()
  Dim data As String
  Dim internal_opts As New Collection
  return_value = 0
  If string_options Like "*-idle *" Then 
    Stop
    Return 'fixmempv
  Endif
  
  If ProcessRunningOvr() Then 
    do_stop()
  Endif
  user_stopped = False 'take this right after the call to do_stop()
  
  internal_opts = internal_options()
  For Each data In internal_opts
    mpvOptions[internal_opts.key] = data
  Next
  
  If global.IsImgFile(filename) Then
    mpvOptions["fps"] = "0.1"
  Endif
  fix_options()
  commandline = executable() & set_options() & string_options
  commandline &= Shell(filename)
  global.myDebug(commandline, commandline)
  last_media = filename
  
  stdout = ""
  stderr = ""
  modules_out = ""

  ExecutePreCmd()
  playerprocess = Shell commandline For Read Write As "playerprocess"

  'The following will be a script that will kill mpv if xt7 crashes:
    Copy "killer.sh" To killer_script
    Chmod killer_script To "rwxr-xr-x"

    Shell killer_script & " " & Application.id & " " & playerprocess.id
    global.myDebug(killer_script & " " & Application.id & " " & playerprocess.id)

  watched_properties_old_data.Resize(watched_properties.count)
  event_loop = New Timer As "event_loop"
  event_loop.delay = 500
  event_loop.start
  setP("fullpath", filename)

  Return True
End

Public Struct chapter
  title As String
  start_time As String
End Struct

Public Struct CDINFO
  Artist As String
  Title As String
  Years As String
  tracks As String[]
End Struct

Private Mycdinfo As Cdinfo
Public Sub get_cdda_info(device As String, Optional cddb As Boolean = True) 
  Dim dcl, t, l, start_time, pstart_time As String
  Dim track As Integer = 0
  Dim length As String = 0
  Dim Mycd As New Cddb
  Dim tName As String

  If cddb Then 
    mycd = New CDDB
    Mycdinfo = mycd.cddb_query(device, 100) 
  Endif

  dcl = get_property_mpv("=chapter_list", True, 10)
  global.myDebug(dcl)
  
  dcl = Replace(dcl, "[", "")
  dcl = Replace(dcl, "]", "")
  dcl = Replace(dcl, "},{", Chr(8))
  dcl = Replace(dcl, "{", "")
  dcl = Replace(dcl, "}", "")  

  start_time = 0
  track = 1
  
  For Each t In Split(dcl, Chr(8), "", True)
    pstart_time = start_time
    start_time = (Split((Split(t, ",")[1]), ":")[1])
    l = CFloat(start_time) - CFloat(pstart_time)
    'Length = mplayer.FormatTime(Split(l, ".,")[0])
    length = Split(l, ".,")[0]
    tName = ""

    If cddb Then Try tName = Trim(Mycdinfo.tracks[track - 1])
    prop["cddbtracks"].add(tname & Chr(8) & length)
    track += 1
  Next 'track
End

Public Function cdda_device(fullpath As String) As String
  'dvd://24//path/to/dvd/device -> /path/to/dvd/device
  'dvd://dev/sr0  -> /dev/sr0
  'dvd://1 -> "/"
  'dvd:// -> "/"
  'dvd://menu//path/to/something -> "/path/to/something"
  Dim t As String
  Dim ret As String
  Try t = Split(fullpath, "/", "", True)[1] ' dvd://24//path/to/dvd/device -> 24
                                            ' dvd:// -> ""
                                            ' dvd:///path/to/dvd/device -> path
  If IsInteger(t) Then 
     ret = Replace(fullpath, "cdda://" & t, "")
       Else
     ret = Replace(fullpath, "cdda://", "")
   Endif
   If Left(ret, 1) <> "/" Then ret = "/" & ret
   Return ret
End

Private Function get_main_cue_property(cuetext As String, tag As String) As String
  Dim cuelines As String[]
  Dim aLine As String
  Try cuelines = Split(cuetext, "\n", "", True)
  If Error Then Return ""
  If cuelines.count = 0 Then Return ""

  For Each aLine In cuelines
    aLine = Trim(UnQuote(aline))
    aLine = Replace(aLine, "\"", "") ' gambas bug with instr() and double quotes :(
    While Not IsAscii(Left(aline)) 'filter out spurious characters at the beginning of the file (?)
      aline = Right(aline, -1)
    Wend

    If InStr(aLine, tag) = 1 Then
      Return Trim(Right(aLine, - Len(tag)))
        Else If InStr(aLine, "REM " & tag) = 1 Then 
          Return Trim(Right(aLine, - Len("REM " & tag)))
    Endif
  Next
End


Public Function get_mediainfo(Optional cddb As Boolean = True, Optional force_audio_only As Boolean = False) As Boolean 
  Dim media_taglib As New TagLib
  Dim fileUtf8 As String
  Dim properties As String[]
  Dim cuetext As String 
  Dim fullpath As String
  
  fullpath = getP("fullpath") 
  
  If fullpath = "" Then Return

' ' ''ENUM Artist, title etc via mpv Metadata
' '     metadatacount = GetPropertympv("metadata/list/count")
' '     If metadatacount > 0 Then
' '       For i = 0 To metadatacount - 1
' '         metadataname = GetPropertympv("metadata/list/" & i & "/key")
' '         global.myDebug( metadataname, GetPropertympv("metadata/by-key/" & metadataname))
' '       Next
' '     Endif
' '   ''

  global.mydebug("Waiting for playback to start")
  If Not waitplayback(3000) Then
    global.myDebug("EE", "Playback didn't started or timeout waiting for it to start")
    do_stop()
    Return False
  Endif
  global.mydebug("started")

  'fixmempv: questa procedura sotto, cosa fa esattamente? mi sembra solo il trim (?)
    Try fileUtf8 = DConv(fullpath) 'from system charset to utf8
    If Error Then fileutf8 = fullpath
    fileutf8 = fullpath
    fileutf8 = Trim(fileutf8)

  FillMultitracks(force_audio_only) 'will set prop[audioonly] too.

  Try setP("size", (Stat(fullpath, True).Size Div 1024))
  
  properties = New String[]
  properties.insert(["filename", "partially-seekable", "file-format", "audio-codec"]) 'common
  'properties.Insert(["=audio-bitrate", "audio-channels", "=audio-channels", "=audio-samplerate"]) 'common
  properties.Insert(["=audio-bitrate", "audio-params/channels", "=audio-params/channels", "=audio-params/samplerate"]) 'common
  If Not getP("audioonly") Then
    properties.Insert(["video-codec", "video-params/dw", "video-params/dh"]) 'video files
  Endif

  
  
  'for audio only files, try to get common audio tags
  'try first to get them using fast taglib
  'fixmempv --> but fallback to mplayer in idle mode <--fixmempv
  If (getP("AudioOnly") And (Not Global.IsNetworkURI(FullPath))) Then
    If media_taglib.IsSupported(fileutf8) And media_taglib.Init(Fullpath) Then
      setP("artist", media_taglib.Artist)
      setP("author", media_taglib.Artist)
      setP("title", media_taglib.Title)
      setP("album", media_taglib.Album)
      setP("genre", media_taglib.Genre)
      setP("year", media_taglib.MyYear)
      setP("comment", Replace(Replace(media_taglib.Comment, "\n", " "), "\r", " "))
      setP("comments", media_taglib.Comment)
      setP("trackno", media_taglib.Track)
      setP("=duration", media_taglib.Length)
      setP("duration", FormatTime(media_taglib.Length))
      If getP("=duration") = 0 Then properties.add("=duration")
      If getP("duration") = 0 Then properties.add("duration")
      setP("=Audio-Bitrate", media_taglib.Bitrate)
      If getP("=Audio-Bitrate") = 0 Then properties.add("=audio-bitrate")
      setP("=audio-params/channels", media_taglib.Channels)
      If getP("=audio-params/channels") = 0 Then properties.add("=audio-params/channels")
      setP("=audio-params/samplerate", media_taglib.Samplerate)
      If getP("=audio-params/samplerate") = 0 Then properties.add("=audio-params/samplerate")
      global.myDebug("got info from taglib on " & Fullpath & " --")
      
       media_taglib.tlFree()
        Else  'there was a problem with TagLib Class initialization, fallback to mplayer
              'or was a network uri or a cddb 
      If global.IsCdaudio(Fullpath) Then 'fixmempv cddb allow to choose if user wants cddb
        get_cdda_info(cdda_device(Fullpath), cddb)
        If cddb Then
          Try setP("Artist", Mycdinfo.Artist)
          Try setP("author", Mycdinfo.Artist)
          Try setP("year", Mycdinfo.years)
          Try setP("year", Mycdinfo.years)
          Try setP("album", Mycdinfo.title)
        Endif
      Endif


      If Not (global.IsCdaudio(Fullpath))
        Try setP("Artist", get_property_mpv("metadata/by-key/ARTIST", True, 2))
        Try setP("Author", get_property_mpv("metadata/by-key/AUTHOR", True, 2))
        Try setP("Genre", get_property_mpv("metadata/by-key/GENRE", True, 2))
        Try setP("Album", get_property_mpv("metadata/by-key/ALBUM", True, 2))
        Try setP("Year", get_property_mpv("metadata/by-key/DATE", True, 2))
        ' Try Media_CreationDate = DConv(FindAudioTag("creation date")) 'fixmempv
        Try setP("TrackNo", get_property_mpv("metadata/by-key/track", True, 2))
        Try setP("Title", get_property_mpv("metadata/by-key/TITLE", True, 2))
        If getP("Title") = "" Then Try setP("name", get_property_mpv("metadata/by-key/TITLE", True, 2))
        ' Try Media_Comment = DConv(FindAudioTag("comment")) ' & Media_ExtraComment 'fixmempv mpv doesnt support comments...
        ' Try Media_Comments = DConv(FindAudioTag("comments")) ' & Media_ExtraComment 'fixmempv mpv doesnt support comments...
      Endif

      If Fullpath Like "*.cue" Then
        Try cuetext = File.Load(fullpath)
        If Not Error Then 
          Try setP("year", get_main_cue_property(cuetext, "DATE"))
          Try setP("comment", get_main_cue_property(cuetext, "COMMENT"))
          Try setP("genre", get_main_cue_property(cuetext, "GENRE"))
          Try setP("artist", get_main_cue_property(cuetext, "PERFORMER"))
          Try setP("author", get_main_cue_property(cuetext, "PERFORMER"))
          Try setP("Album", get_main_cue_property(cuetext, "TITLE"))
        Endif
      Endif
      
      
      If (getP("=duration") = 0) Or (getP("=duration") = "") Then properties.insert(["=duration", "duration"])

    Endif
        Else 'for not audio only files, use mpv
      properties.insert(["=duration", "duration"])
      If (Not getP("audioonly")) Then
        properties.Insert(["=video-bitrate", "width", "height", "fps"])            
      Endif

  Endif

  get_properties_mpv(properties)
  
  If getP("duration") = "" Then setP("duration", "00:00:00")
  If getP("=duration") = "" Then setP("duration", "0")
  Return True
End


Public maxcache As String = "0"

Private Function parsecacheparam(commandline As String) As String
Dim start As Integer
Dim tmp As String
  If commandline Like "* -cache *" Then
    start = InStr(commandline, "-cache")
    tmp = Mid(commandline, start, Len(commandline))
    tmp = Trim(tmp)
    tmp = Split(tmp, " ", "", True, False)[1]
    tmp = Trim(tmp)
    Return tmp
      Else
    Return "0"
  Endif
End





Private Function TemporaryPlaylist(Fullpath As String) As String
  'This is an hack because mplayer in idle mode doesn't like some filenames (i can't understand why)

  Dim tmpfile As File
  Dim PlaylistFileName As String = Temp("mytmpfile")

  tmpfile = Open PlaylistFileName For Write Create
  Print #tmpfile, Fullpath
  Close tmpfile
  Return PlaylistFileName

End

Public Function do_preload(filename As String, timeout As Integer)
  Dim cmd As String
  cmd &= executable(timeout) & " "
  cmd &= "--cache=no --vo null --ao=null --speed=2 "
  cmd &= "'" & filename & "'" & " "
  cmd &= "&>/dev/null"
  Shell cmd
End

Public idleplaying As Boolean = False

Public Function do_IdlePlay(filename As String) As Boolean
  'warning: call this function is mutually exclusive to calling do_play()
  'eg: if you started mpv with do_play(), you need another instance Of this class.
  'check if the process is alive || start it
  ClearMediaProperties()
  If Not ProcessRunningOvr() Then
    mpvoptions.Clear
    set_option("input-file", SetUpInputPipe())
    set_option("msg-color", "no")
    'set_option("term-status-msg", "")    
    set_option("term-status-msg", play_initialized_str)
    set_option("ao", "null")   
    set_option("vo", "null")   
    set_option("idle", "yes")
    set_option("cache", "no")
    commandline = executable(600) & set_options()
    idleplaying = True
    playerprocess = Shell commandline For Read Write As "playerprocess"
      Else
    set_property_mpv("options/term-status-msg", play_initialized_str)
  Endif
  
  mpv_command(["loadfile", SConv(FileName)])
  setP("fullpath", filename)
  do_leave_pause(False)
  If Not quick Then get_mediainfo(False)
  mpv_command(["stop"])
End




Public Function DoDeinterlace()
  If commandline Like "*vdpau*" Then
    send("step-property deinterlace")
    Return
  Endif
  If commandline Like "*yadif*" Then
    send("step-property deinterlace")
    Return
  Endif
  If commandline Like "*xvmc*" Then
    send("step-property deinterlace")
    Return
  Endif
  If commandline Like "*vaapi*" Then
    send("step-property deinterlace")
    Return
  Endif
  If commandline Like "*kerndeint*" Then
    send("step-property deinterlace")
    Return
  Endif
  ShowText("Can't deinterlace, missing vdpau,xvmc,vaapi,yadif or kerndeint", 3000)
End


Public AudioSwitched As Boolean = False


Private SUPPORTEDAUDIOFILTERS As New String[] 
' Public Sub afclr() 'fixmempv
'   'get the current audio filters and remove them one by one.
'   'needed because -af_clr slave command doesn't seem to work.
'   Dim out, filter As String
'   If SUPPORTEDAUDIOFILTERS.count = 0 Then 
'     Shell executable() & " -af help |grep ' : '" To out 
'     For Each filter In Split(out, "\n", "", True)
'       SUPPORTEDAUDIOFILTERS.add(Split(Trim(filter), " ", "", True)[0])
'     Next 'filter
'   Endif
'   For Each filter In SUPPORTEDAUDIOFILTERS
'     send("af_del " & filter) 'do it four times to be sure multiple instances
'     send("af_del " & filter) 'of the same filter are removed as well
'     send("af_del " & filter)
'     send("af_del " & filter)
'   Next 'filter
' End



Public Sub ExecutePreCmd()
  If Trim(PreCommand) <> "" Then 
    Shell DConv(preCommand) Wait
  Endif
End

Public Sub ExecutePostCmd()
  If Trim(PostCommand) <> "" Then 
    Shell DConv(PostCommand) Wait
  Endif
End


Event user_stopping(fullpath As String, timepos As String)

Public Function ProcessRunningOvr() As Boolean
  'As gambas returns runtime error if process is not ready,
  'we'll catch it here
  Dim running As Boolean = False
  Try running = (playerprocess.state = 1)
  Return running
End

Public Function do_stop() As Boolean
  Dim maxtimeout As Integer = 100
  Dim timeout As Integer 
  Try event_loop.Stop
  Try mpAnalyze.kill
  AudioSwitched = False
  stopping = True

  If Not restarting Then 
    If ProcessRunningOvr() Then 
      user_stopped = True
      Raise user_stopping(getP("fullpath"), getP("=time-pos"))
    Endif
    ClearMediaProperties()
    properties_changed_runtime.clear
    StopOverBrightAnalyze()
  Endif
  timeout = maxtimeout
  Repeat 'be kind
    send("quit")
    Wait 0.01
    timeout = timeout - 1
  Until ((timeout <= 0) Or (Not ProcessRunningOvr()))
  timeout = maxtimeout
  Repeat 'ne rude !
    Try Playerprocess.Kill
    Wait 0.01
    timeout = timeout - 1
    Until ((timeout <= 0) Or (Not ProcessRunningOvr()))

  Try Close #mystream
  Try Kill inputpipe
  Return True
End


Public Function do_ffwd() As Boolean
  If Not ProcessRunningOvr() Then Return
  mpv_command(["multiply", "speed", "1.059463094352953"])
End

Public Function do_slow() As Boolean
  If Not ProcessRunningOvr() Then Return
  mpv_command(["multiply", "speed", "0.9438743126816935"])
End


Public Function do_SetVolume(Percentual As String, Optional osd As Boolean = False) As Boolean
  If Not ProcessRunningOvr() Then Return
  set_property_mpv("volume", Percentual, osd)
End


Public Function do_volume_add(Percentual As String, Optional osd As Boolean = False) As Boolean
  If Not ProcessRunningOvr() Then Return
  set_property_mpv("volume", Percentual, osd)
End

'######################### Media Properties Section






Public Function CurrentTime(Optional cached As Boolean = False) As String
  Dim reply As String
  If Not ProcessRunningOvr() Then Return "0" 
  reply = get_property_mpv("=time-pos", True,, cached)
  Try Return Split(reply, ".")[0]
  If Error Then Return "0"
End

Public Sub CurrentTimeFloat(Optional cached As Integer = False) As String
  Dim out As String
  If Not ProcessRunningOvr() Then Return "0"
  out = get_property_mpv("=time-pos", True,, cached)
    If out = "" Then 
      Return "0"
    Else
      Return out
  Endif
End


Public Sub ShowText(message As String, Optional myTime_ms As Integer = 2000)
  mpv_command(["show_text", message, mytime_ms])
End

Public Function IsSubFile(SubfilePath As String) As Boolean

  Dim SubExtensions As String = "*.SRT;*.ASS;*.SUB;*.SSA;"
  Dim fileExt As String = "." & File.Ext(SubfilePath)

  If Fileext = "." Then Return False
  If (InStr(Upper(SubExtensions), Upper(fileExt)) > 0) Then
    Return True
  Else
    Return False
  Endif

End


Public Sub sub_add(file As String, UseSub As Boolean)
  If Usesub Then 
    mpv_command(["sub-add", file, "select"])
      Else
    mpv_command(["sub-add", file])
  Endif
End


Public Function get_screenshot(DeleteFILE As Boolean) As Picture

  Dim Screenshot As Picture
  Dim timeout As Integer = 20
  Dim picfile As String = Temp() & ".jpg"
 
  If Not ProcessRunningOvr() Then Return
  Try Kill picfile

  mpv_command(["no-osd", "screenshot_to_file", picfile, "video"])

  While Not Exist(picfile) 'wait for mplayer answer
    Wait 0.05
    timeout = timeout - 1
  Wend
  If timeout <= 0 Then Goto errorlabel
  timeout = 20
  Repeat 'try to load the picture and eventually wait for it to be written on the disk
    Try Screenshot = picture.Load(picfile)
    If screenshot = Null Then
      Wait 0.05
      timeout = timeout - 1
    Endif
  Until (screenshot <> Null) Or timeout <= 0
  If timeout <= 0 Then Goto errorlabel

  If Deletefile Then Try Kill picfile
  Return Screenshot

  errorlabel:
    If Deletefile Then Try Kill picfile
    global.myDebug("Timeout Error: Screenshot file does not exists!")
    Return picture["null.png"]
End


Public Sub FormatTime(seconds As String) As String

  Dim iseconds, hh, mm, ss, restosec As Integer
  Dim Shh, Smm, Sss As String
  If seconds = "" Then Return "00:00:00"
  seconds = Split(seconds, ".", "", True)[0]
  Try iseconds = Val(seconds)
  If Error Then iseconds = 0
  hh = iseconds Div 3600
  restosec = (iseconds - (hh * 3600))
  mm = restosec Div 60
  ss = (restosec - (mm * 60))
  Sss = ss
  If Len(Sss) = 1 Then Sss = "0" & Sss
  Smm = mm
  If Len(Smm) = 1 Then Smm = "0" & Smm
  Shh = hh
  If Len(Shh) = 1 Then Shh = "0" & Shh
  Return Shh & ":" & Smm & ":" & Sss

End

Public Function DeFormatTime(FormattedTime As String) As String

  Dim ss, mm, hh As Integer

  Try ss = Split(FormattedTime, ":")[2]
  If Error Then ss = "0"
  Try mm = Split(FormattedTime, ":")[1]
  If Error Then mm = "0"
  Try hh = Split(FormattedTime, ":")[0]
  If Error Then hh = "0"
  Return ss + (mm * 60) + (hh * 3600)


End



Public Sub Media_get_length() As String

  ' Dim t1 As String = ""
  ' Dim ofpos, i As Integer = 0
  ' 
  ' 
  ' 'Next, let's see if it is an audio only or an audio/video file,
  ' 'we need to know because of buggy ID_LENGTH behaviour:
  ' 
  ' If Media_AudioOnly() Then
  '   i = MediaHeaders.Count - 1        'we'll reverse the search here to speedup, probably
  '   Repeat
  '     t1 = Trim(MediaHeaders[i])
  '     If (t1 Like "*)*") And (t1 Like "* of *") And (t1 Like "*%*") And (t1 Like "*:*") And Not (InStr(t1, Media_FullPath)) Then
  '       ofpos = InStr(t1, " of ")
  '       'clear all the chars before " of " (included):
  '       Media_Length = Mid(t1, ofpos + 4, 10)
  '       'find first space
  '       ofpos = InStr(t1, " ")
  '       'copy the string until that
  '       Media_Length = Mid(Media_Length, 1, ofpos)
  '       Return Media_Length
  '     Endif
  '     i = i - 1
  '   Until (i = 0) Or (Media_Length <> "0")
  '   
  ' Else 'is a video/audio file
  '   i = 0
  '   Repeat
  '     Try t1 = Trim(MediaHeaders[i]) 'fixme
  '     If (t1 Like "*ID_LENGTH*") Then
  '       Media_Length = GetTagValue(t1, "ID_LENGTH")
  '     Endif
  '     i = i + 1
  ' 
  '   Until (i >= MediaHeaders.Count) Or (Media_Length <> "0")
  ' Endif
  ' Return Media_Length

End

Public Function DeMuxerslist() As String[]
  'returns a string array of supported audio codecs plus informations

  Dim MPoutput As String
  Dim MPLines, FuncOUT As New String[]
  Dim MPLine, MPWord As String
  Dim HeadSkipped As Boolean = False
  Dim CheckHead As String = "demuxer:"
  Dim Option As String = " --config=no -demuxer help"
  Dim spaces_before As String = ""

  CheckHead = "demuxer:"
  
  Shell executable() & " " & Option To MPoutput
  MpLines = Split(MPOutput, "\n", "", True)
  For Each MPLine In MPLines
    MPWord = Trim(Split(MPLine, " ", "", True)[0])
    If MPWord = CheckHead Then HeadSkipped = True
    ' 'get just the first word
    If HeadSkipped And mpword <> CheckHead Then
      spaces_before = "  "
      'Move white spaces From nefore the word To the End Of the word
      While Left(mpline) = " " 
        mpline = Right(mpline, -1)
        spaces_before &= " "
      Wend
      MPWord = MPWord & spaces_before & Right(mpline, - Len(mpword))
      FuncOUT.Add((MPWord))
    Endif
  Next
  Return FuncOut

End


Public Function CodecsList(TYPE As String) As String[]
  'returns a string array of supported audio codecs
  'returns a string array of supported audio codecs plus informations
  Dim MPoutput As String
  Dim MPLines, FuncOUT As New String[]
  Dim MPLine As String
  Dim HeadSkipped As Boolean = False
  Dim CheckHead As String = "demuxer:"
  Dim Option As String = " --config=no -demuxer help"
  Dim cname, cdesc As String

  If TYPE = "AUDIO" Then
    CheckHead = "Audio decoders:"
    Option = " --config=no  -ad help"
  Else
    CheckHead = "Video decoders:"
    Option = " --config=no  -vd help"
  Endif
  Shell executable() & " " & Option To MPoutput
  MpLines = Split(MPOutput, "\n", "", True)
  For Each MPLine In MPLines
    cname = ""
    cdesc = ""
    mpline = Trim(mpline)
    If mpline = CheckHead Then HeadSkipped = True
    ' 'get just the first word
    If HeadSkipped And mpline <> CheckHead Then
      cname = Trim(Split(mpline, "-", "", True)[0])
      cdesc = Trim(Split(mpline, "-", "", True)[1])
      Repeat 
        cname &= " "
      Until Len(cname) >= 40
      FuncOUT.Add((cname & cdesc))
    Endif
  Next

  Return FuncOut

End


Public Function GetListOf(TheType As String) As String[]
  'return a list of available drivers/filters
  'thetype can be ao,vo,af,vf
  Dim list, mpline As String
  Dim outlist As New String[]
  Shell executable() & "  --config=no -" & TheType & " help" To List
  global.myDebug(Timer)
  For Each mpline In Split(list, "\n", "", True)
    outlist.Add(Lower(Split(mpline, " \t", "", True)[0]))
  Next 'mpline
  Return outlist
End




Public thumbprocess As Process
Private newfilenamepriv As String
Private outdirpriv As String
Private Thumbfullpathpriv As String
Private widthpriv As Integer
Private columnpriv As Integer
Private rowpriv As Integer
Private gridpriv As Gridview



Public Sub savethumb(fullpath As String, newfilename As String, Optional width As Integer = 256, Optional seconds As Integer = 300, mygrid As Gridview, row As Integer, column As Integer) 
  Dim outdir As String = Temp() & Rnd(0, 99999)
  Dim cmdline As String = ""

  Mkdir outdir

  rowpriv = row
  columnpriv = column
  gridpriv = mygrid

  'Create the thumb, but exit after 30 seconds 
  cmdline = executable(5) & " " & Shell(fullpath) & " --cache=no "
  cmdline &= "-vf scale=" & width & ":-2" & ",expand=::::1/1" & " --no-sub" & " --start " & seconds 
  cmdline &= " -frames 1 --no-audio --vo=image:format=jpg:jpeg-quality=80:outdir=" & outdir
  cmdline &= " --config=no -quiet &>/dev/null"

  newfilenamepriv = newfilename
  outdirpriv = outdir
  Thumbfullpathpriv = fullpath
  widthpriv = width
  global.myDebug(cmdline)
  global.myDebug("")
  thumbprocess = Shell cmdline For Input As "thumbprocess" 
End

Private restarting As Boolean = False
Public Sub playerprocess_kill()
  return_value = playerprocess.value
  If (Not restarting) Then 
    ClearMediaProperties()

    Raise mykill(return_value)

    'post cmd is supposed to be filled in the mykill() event handler.
    ExecutePostCmd()
  Endif
End

Event mykill(return_value As Integer)
Event ThumbAvailableFor(fullpath As String, g As Gridview, r As Integer, c As Integer)
Event ThumbErrorFor(fullpath As String, g As Gridview, r As Integer, c As Integer)


Private ShortMovieChecked As Boolean = False
Public Sub thumbprocess_kill()
  Try Copy outdirpriv & "/" & Dir(outdirpriv, "*")[0] To newfilenamepriv
  Shell "rm -R " & outdirpriv & "&>/dev/null"
  If Exist(newfilenamepriv) Then
    Raise ThumbAvailableFor(Thumbfullpathpriv, gridpriv, rowpriv, columnpriv)
      Else
    If ShortMovieChecked Then 
      Raise ThumbErrorFor(Thumbfullpathpriv, gridpriv, rowpriv, columnpriv)
        Else 'maybe the movie was very short, try to get a screen at 5th second:
      global.myDebug("Couldn't get a thumb, retrying with an earlier time")
      ShortMovieChecked = True
      savethumb(Thumbfullpathpriv, newfilenamepriv, widthpriv, 150, gridpriv, rowpriv, columnpriv)
    Endif
  Endif
End



Public Sub ExtractAudioTo(src As String, dest As String)
  do_play(src, " -vo null -vc null -ao pcm:waveheader:fast:file=" & dest, False, False)
End


Public Sub StartOverbrightAnalyze()
  If Not ProcessRunningOvr() Then Return
  stopob = False
  TimerAnalyzePRE = New Timer As "TimerAnalizePRE"
  TimerAnalyzePRE.Delay = 10
  TimerAnalyzePRE.start
End

Private StopOB As Boolean = False
Public Sub StopOverBrightAnalyze()
  Try mpanalyze.kill
  Try TimerAnalyzePRE.stop
  Try TimerAnalyze.stop
  Try mpanalyze.kill
  StopOB = True
End




Private barray As String[]
Public mpAnalyze As Process
Private PrevCtime As Integer = -1

Public Sub Analyze(videofile As String)
  Dim cmd As String
  Dim newpos As Integer
  Dim i As New Image
  Dim bAvg As Integer
  Dim tmpdir As String = Temp() & "/"
  Dim pLine, t As String
  Dim mystream As File
  Dim cTime, cTimei, cTimef As String
  Dim outfile As String[]
  Dim sFile As String
  Dim timeout As Integer
  lStart:
  While ProcessRunningOvr()
    If stopob Then Goto lEnd
    barray = New String[80000] 
    barray.Fill(-1, 0, 80000)
    Shell "rm -Rf " & tmpdir Wait
    Shell "mkdir -p " & tmpdir Wait
    Shell "rm " & tmpdir & "/fifo" Wait
    Shell "mkfifo " & tmpdir & "/fifo" Wait
    Try mystream.close
    mystream = Open tmpdir & "/fifo" For Write
    Print #mystream, "no-osd set pause yes"
    'cmd = "mplayer  -noconfig all -noautosub -nosub -osdlevel 0  -lavdopts fast:skiploopfilter=all -speed 0.01 -slave -input file=" & tmpdir & "/fifo  -vf scale=64:64:0:3,scale=16:16:0:3,smartblur=5:1:0,scale -nosound -vo jpeg:quality=100:outdir=" & tmpdir & " " & videofile & " </dev/null &> " & tmpdir & "/mpout"
    cmd = executable() & " --term-status-msg='${=time-pos}' --config=no --no-sub --osd-level=0 --vd-lavc-skiploopfilter=all --speed 0.01 --input-file=" & tmpdir & "/fifo --vf=scale=16:16  --no-audio --vo=image:format=png:outdir=" & tmpdir & " " & videofile & " </dev/null &> " & tmpdir & "/mpout"
    'cmd = "mplayer  -noconfig all -noautosub -nosub -osdlevel 3  -lavdopts fast:skiploopfilter=all -speed 0.01 -slave -input file=" & tmpdir & "/fifo  -nosound -vo jpeg:quality=100:outdir=" & tmpdir & " " & videofile & " </dev/null &> " & tmpdir & "/mpout"
    global.myDebug(cmd)
    mpanalyze = Shell cmd
    Repeat
      If stopob Then Goto lEnd
      Sleep 0.05
      Try t = File.Load(tmpdir & "/mpout")
    Until (Not Error )
    Repeat
      Try outfile = Split(File.Load(tmpdir & "/mpout"), "\n")
      Sleep 0.05
    Until (outfile.max > 1)

    While mpanalyze.state = Process.Running
      'Debug
      If stopob Then Goto lEnd
      For Each sFile In Dir(tmpdir, "*.png*")
        Kill tmpdir & "/" & sFile
      Next
      
      'step ahead
       newpos = CInt(currenttime()) + 4
      If Not Error Then 
        'Print #mystream, "pausing_keep seek " & CStr(newpos) & " 2"
        Print #mystream, "no-osd seek " & CStr(newpos) & " absolute keyframes"
        'Debug "Analize newseek", newpos
      Endif
      Repeat
        'If paused Or pausing Then TimerAnalyze.stop
        If paused() Then TimerAnalyze.stop
        Wait 1
        If stopob Then Goto lEnd
      Until Not paused()
      'Until Not (paused Or pausing)
      TimerAnalyze.start
      'Print #mystream, "pausing_keep seek +1"
      
      'wait for pic
      timeout = 100
      If Not Exist(tmpdir) Then Goto lStart
      While Dir(tmpdir, "*.png").count = 0 And (timeout > 0) And mpanalyze.state = Process.Running
        Wait 0.01
        timeout -= 1
      Wend
      If timeout = 0 Then 
        global.myDebug("No Pics, restarting analyzer")
        Try mpanalyze.Kill
        Goto lStart
      Endif
      
      '''''''''If (timeout <= 0) Or (mpanalyze.state <> Process.Running) Then Goto lEnd
      outfile = Split(File.Load(tmpdir & "/mpout"), "\n\r", "", True) '<- this is sloooow over time, watchout!

      
      pLine = outfile[outfile.max - 1]
      'Try cTime = Val(Trim(Mid(pLine, 3, InStr(pLine, ".") - 3)))
      'Try ctime = CFloat(Trim(Mid(pLine, 3, InStr(pLine, ".") - 1))) 'get the current float time
      Try ctime = CFloat(Trim(pLine)) 'get the current float time
      
      Try cTimei = Split(cTime, ".")[0]
      Try cTimef = Split(cTime, ".")[1]
      Try t = tmpdir & Dir(tmpdir, "*.png")[0]
      If Exist(t) Then
        Try i = i.Load(tmpdir & Dir(tmpdir, "*.png")[0])
        'Shell "mv  " & (tmpdir & Dir(tmpdir, "*.jpg")[0]) & " /tmp/tmp/" & ctime & ".jpg" Wait
        If Not Error Then 
          bavg = c_mean(i)
          'bavg = Color[i.Pixels[0]].value 
          'global.myDebug("time", ctime, "AVG:", bavg)
          'barray index represents the integer part of the time, so we store the float part with the average picture brightness value in the array cell
          'and set a delay afterwards for near pefect timing
          Try barray[cTimei] = bAvg & ":" & ctimef
          
        Endif
      Endif
    Wend
  Wend
  lEnd:
  stopob = False
  mpanalyze.kill
  Shell "rm -Rf " & tmpdir
End

Private Function c_mean(img As Image) As Integer
Dim i, s As Integer
Dim skiprows As Integer = img.Pixels.count Div 8
'an imprecise color mean
  For i = skiprows To img.Pixels.Count - skiprows Step 3
    s += Color[img.Pixels[i]].value
  Next
  Return CInt(s / (img.Pixels.count - (skiprows * 2))) * 3
End

Public TimerAnalyzePre As Timer
Public Sub TimerAnalizePRE_timer()
  TimerAnalyzePRE.stop
  TimerAnalyze = New Timer As "TimerAnalize"
  TimerAnalyze.delay = 33 'should be ok till 30fps source material
  TimerAnalyze.start
  Analyze(Shell(SConv(getP("FullPath"))))
End

Public TimerAnalyze As Timer

Event AnalyzerNewValue(bAvg As Integer, delay As Float)

Public Sub TimerAnalize_timer()
  Dim cTime As Integer
  Dim bAvg As String
  Dim delay As Float
  Try cTime = CInt(CurrentTime())
  If Error Then Return
  If PrevCtime = cTime Then Return
  prevCtime = cTime
  If ctime < 0 Then Return
  bAvg = Split(barray[ctime], ":")[0]
  If bAvg <> -1 Then
    TimerAnalyze.Stop
    'Debug "New value at index", i, bout[3]
    'ShowText("Tempo media: " & ctime & " media: " & bAvg & " Tempo filmato " & CurrentTimeFloat())
    'ShowText("barray: " & ctime & "movie: " & CurrentTimeFloat(), 1000)
    delay = CFloat("0." & Split(barray[ctime], ":")[1])
    delay = delay - (CFloat(CurrentTimeFloat()) - cTime)

    Try Raise AnalyzerNewValue(bAvg, delay, cTime)
    global.myDebug("NewValue")
    If Not stopob Then TimerAnalyze.start
      'Else
    'Debug "missing value in barray"
  Endif
End


Private mystream As Stream
Private Function SetUpInputPipe() As String
  Dim Random1 As Integer = 0
  Randomize
  Random1 = Int(Rnd(0, 65535))
  Try Mkdir global.confpath & "/.InputPipes"
  inputpipe = global.confpath & "/.InputPipes/Xt7Input-" & Random1
  If Exist(inputpipe, True) Then 
    Shell "rm '" & inputpipe & "' &>/dev/null" Wait
  Endif
  mystream = Pipe inputpipe For Write
  global.myDebug("inputpipe=", inputpipe)

  Return inputpipe
End


Public Function do_pause() As Boolean
  set_property_mpv("pause", "yes")
  Return get_property_mpv("pause", True) = "yes"
  'fixmempv cicla finchè non in pausa
End


Public Function do_leave_pause(Optional check As Boolean = True) As Boolean
  set_property_mpv("pause", "no")
  If check Then 
    Return get_property_mpv("pause", True) = "no"
      Else
    Return True
  Endif
End


Private properties_changed_runtime As New Collection 'holds changed properties to be set again after a restart

Public Function set_property_mpv(name As String, data As String, Optional osd As Boolean = False) 
  'mpv_command(["set_property_string", name, data])
  Dim s As String = "\\"
  Dim q As String = "\""

  data = Replace(data, q, s & q)        'replace " with \"
  data = Replace(data, s & s & q, s & q) 'replace \\" with \" (in case we quoted an already quoted string)
  If osd Then 
    mpv_command(["osd-msg", "set", name, data])
      Else
    mpv_command(["no-osd", "set", name, data])
  Endif
  properties_changed_runtime[name] = data

End

Public Function add_property_mpv(name As String, data As String, Optional osd As Boolean = False) 
  'mpv_command(["set_property_string", name, data])
  Dim s As String = "\\"
  Dim q As String = "\""

  data = Replace(data, q, s & q)        'replace " with \"
  data = Replace(data, s & s & q, s & q) 'replace \\" with \" (in case we quoted an already quoted string)
  If osd Then 
    mpv_command(["osd-msg", "add", name, data])
      Else
    mpv_command(["no-osd", "add", name, data])
  Endif
  properties_changed_runtime[name] = data

End


Private available_options As New String[]

Public Sub list_options() As String[]
  Dim o, opts As String
  If available_options.count > 0 Then Return available_options
  Shell executable() & " --list-options|grep '\\-\\-'|cut -d '-' -f 3-|cut -d ' ' -f 1" To opts
  For Each o In Split(opts, "\n", "", True)
    available_options.Add(o)
  Next
  Return available_options
End



Public Function old_get_property_mpv(name As String, Optional wait_answer As Boolean = True, Optional timeoutcentisecs As Integer = 100, try_cached As Boolean = False) As String
  Dim dataout As String
  Dim cachedP As Variant
  If try_cached Then
    Try cachedP = getP(name)
     If cachedP <> Null Then Return cachedP
  Endif

  dataout = "print-text "
  dataout &= "ANS_" & name & "|"
  dataout &= "${"
  dataout &= name
  dataout &= ":"
  dataout &= unavailable_str
  dataout &= "}"
  'clear previous answer
   If wait_answer Then setP(name, Null)
  'say mpv to answer 
  send(dataout)
  'Debug "asking ", dataout
  If wait_answer Then
    While (timeoutcentisecs >= 0) And ProcessRunningOvr()
      Wait 0.1
      'global.myDebug("got answer?")
      If getP(name) <> Null Then Return getP(name)
      timeoutcentisecs -= 10
      global.myDebug("query has missing answer for property " & name & ", reasking...")
      send(dataout)
      ' global.myDebug( "asking ", dataout)
    Wend
    'global.myDebug( name & " --> " & getP(name))
    Return getP(name)
  Endif
End

Public Function get_property_mpv(name As String, Optional wait_answer As Boolean = True, Optional timeout_sec As Integer = 10, try_cached As Boolean = False) As String
  Dim cachedP As Variant
  Dim answer As String
  If try_cached Then
    Try cachedP = getP(name)
     If cachedP <> Null Then Return cachedP
  Endif

  get_properties_mpv([name], wait_answer, False, timeout_sec)

  Try Return getP(name)
End

Private Function OLD_ask_for(name As String, not_retrived As String, clear_first As Boolean)
  Dim dataout As String
  dataout = "print-text "
  dataout &= "ANS_" & name & "|"
  dataout &= "${"
  dataout &= name
  dataout &= ":" & not_retrived
  dataout &= "}"
  'clear previous answer
  If clear_first Then setP(name, Null)
  'say mpv to answer 
  send(dataout)
End

Private Function ask_for(name As String, not_retrived As String)
  Dim dataout As String
  dataout = "print-text "
  dataout &= "ANS_" & name & "|"
  dataout &= "${"
  dataout &= name
  dataout &= ":" & not_retrived
  dataout &= "}"
  send(dataout)
End


' Public Function old_get_properties_mpv(names As String[], Optional wait_answer As Boolean = True, Optional wait_unavailable As Boolean = False, Optional timeoutcs As Integer = 500)
'   Dim name, dataout, p As String
'   Dim got As Boolean
'   For Each name In names
'     dataout = "print-text "
'     dataout &= "ANS_" & name & "|"
'     dataout &= "${"
'     dataout &= name
'     dataout &= ":(unavailable)}"
'     'clear previous answer
'     If wait_answer Then setP(name, Null)
'     'say mpv to answer 
'     send(dataout)
'   Next 'name
'   
'   If Not wait_answer Then Return
'   'wait for all of the answers
'   Repeat
'     If (Not got) Then
'       Wait 0.01
'       timeoutcs -= 0.01
'     Endif
'     got = True
'     For Each name In names
'       p = getP(name) 
'       If wait_unavailable Then 
'         If (p <> Null) And (p <> "(unavailable)") Then names.Remove(names.Find(name))
'           Else
'         If (p <> Null) Then names.Remove(names.Find(name))
'       Endif
'       got = (got And (p <> Null))
'       If Not got Then 
'         global.myDebug("waiting", name)
'       Endif
'     Next
'   Until got Or (Not ProcessRunningOvr()) Or (timeoutcs <= 0)
' End

Public Function OLD_old_get_properties_mpv(names As String[], Optional wait_answer As Boolean = True, Optional wait_unavailable As Boolean = False, Optional timeoutcs As Integer = 500)
  Dim name, dataout, p As String
  Dim unanswered As String = Chr(8) & "unanswered" & Chr(8) 'indica che mpv non ha risposto
  Dim got As Boolean
  For Each name In names
    dataout = "print-text "
    dataout &= "ANS_" & name & "|"
    dataout &= "${"
    dataout &= name
    dataout &= ":(unavailable)}"
    'clear previous answer
    If wait_answer Then setP(name, Null)
    'say mpv to answer 
    send(dataout)
  Next 'name
  
  If Not wait_answer Then Return
  'wait for all of the answers
  'setP(name, unanswered)
  Repeat
    If (Not got) Then
      Wait 0.01
      timeoutcs -= 0.01
    Endif
    got = True
    For Each name In names
'Stop
      p = getP(name, unanswered) 
      If wait_unavailable Then 
        If (p <> unanswered) And (p <> "(unavailable)") Then names.Remove(names.Find(name))
          Else
        If (p <> unanswered) Then names.Remove(names.Find(name))
      Endif
      got = (got And (p <> unanswered))
      If Not got Then 
        global.myDebug("waiting", name)
      Endif
    Next
  Until got Or (Not ProcessRunningOvr()) Or (timeoutcs <= 0)
End


Public Const unavailable_str As String = "(unavailable)"


Public Function get_properties_mpv(names As String[], Optional wait_answer As Boolean = True, Optional wait_unavailable As Boolean = False, Optional timeout_sec As Integer = 5)
  Dim name, dataout, p As String
  Dim unanswered As String = Chr(8) & "unanswered" & Chr(8) 'indica che mpv non ha risposto
  Dim got As Boolean
  Dim time_zero As Float = Timer()
  Dim p_timestamp As Float = -1
  Dim time_waited As Float
  Dim hammer_time As Float = 0.01
  Dim hammer_time_max As Float = 0.5
  For Each name In names
    ask_for(name, unavailable_str)
  Next 'name

  If Not wait_answer Then Return

  'wait for all of the answers
  Repeat
    If (Not got) Then
      Wait hammer_time
    Endif
    got = True
    For Each name In names
      p = getP(name) 
      p_timestamp = getP_time(name)
      If wait_unavailable Then 
        If (p_timestamp > time_zero) And (p <> unavailable_str) Then names.Remove(names.Find(name))
          Else
        If (p_timestamp > time_zero) Then names.Remove(names.Find(name))
      Endif
      got = (got And (p_timestamp > time_zero))
      If Not got Then 
        global.myDebug("waiting for", name, "reasking...")
        'hammer_time += 0.01
        hammer_time *= 2
        If (hammer_time >= hammer_time_max) Then hammer_time = hammer_time_max
        global.myDebug(CStr(timeout_sec - time_waited) & " to timeout.", "hammering every " & CStr(hammer_time) & " seconds.")
        ask_for(name, unavailable_str)
          Else
        global.myDebug("Got answer to " & name & " in " & CStr(p_timestamp - time_zero), "Answer is: " & p)
      Endif

    Next
    time_waited = (Timer() - time_zero)
    
  Until got Or (Not ProcessRunningOvr()) Or (time_waited > timeout_sec)
End




Public Function old_get_properties_mpv(names As String[], Optional wait_answer As Boolean = True, Optional wait_unavailable As Boolean = False, Optional timeout_sec As Integer = 5)
  Dim name, dataout, p As String
  Dim unanswered As String = Chr(8) & "unanswered" & Chr(8) 'indica che mpv non ha risposto
  Dim got As Boolean
  Dim time_zero As Float = Timer()
  Dim time_waited As Float
  Dim hammer_time As Float = 0.01
  Dim hammer_time_max As Float = 0.5
  For Each name In names
    ask_for(name, unavailable_str, wait_answer)
  Next 'name
  If get_option("vd-lavc-skiploopfilter") = "all" Then
    'Stop
  Endif
  If Not wait_answer Then Return
  'wait for all of the answers
  'setP(name, unanswered)
  Repeat
    If (Not got) Then
      Wait hammer_time
    Endif
    got = True
    For Each name In names
'Stop
      p = getP(name, unanswered) 
      If wait_unavailable Then 
        If (p <> unanswered) And (p <> unavailable_str) Then names.Remove(names.Find(name))
          Else
        If (p <> unanswered) Then names.Remove(names.Find(name))
      Endif
      got = (got And (p <> unanswered))
      If Not got Then 
        global.myDebug("waiting for", name, "reasking...")
        'hammer_time += 0.01
        hammer_time *= 2
        If (hammer_time >= hammer_time_max) Then hammer_time = hammer_time_max
        global.myDebug(CStr(timeout_sec - time_waited) & " to timeout.", "hammering every " & CStr(hammer_time) & " seconds.")
        global.myDebug("Answer (p) is:", p)
        ask_for(name, unavailable_str, wait_answer)
      Endif
    Next
    time_waited = (Timer() - time_zero)
    
  Until got Or (Not ProcessRunningOvr()) Or (time_waited > timeout_sec)
End

Public Function paused(Optional cached As Boolean = False) As Boolean
  Return get_property_mpv("pause",,, cached) = "yes"
End

' Private Sub mpv_command(command As String[])
'   Dim snip, sbuf As String
' 
'   sbuf = "{ \"command\": ["
'     For Each snip In command
'       sbuf &= "\"" & snip & "\", "
'     Next
'     sbuf = Left(sbuf, -2)
'   sbuf &= "] }" & "\n" '<-serve l'accapo finale? il send già lo manda
' 
'   global.myDebug( sbuf)
'   send(sbuf)
' End

Public Sub mpv_command(command As String[])
  Dim snip, sbuf As String
  For Each snip In command
    sbuf &= "\"" & snip & "\"" 
    sbuf &= " "
  Next
  sbuf = Left(sbuf, -1)
  send(sbuf)
  global.myDebug(sbuf)
End


Public Sub abloop_set_a(Optional timefloat As String = "notset") 'no argument means current time.
  If timefloat = "notset" Then
      set_property_mpv("ab-loop-a", "${=time-pos}")
        Else
      set_property_mpv("ab-loop-a", timefloat)
  Endif
End

Public Sub abloop_set_b(Optional timefloat As String = "notset") 'no argument means current time.
  If timefloat = "notset" Then
      set_property_mpv("ab-loop-b", "${=time-pos}")
        Else
      set_property_mpv("ab-loop-b", timefloat)
  Endif
End

Public Function do_revert_seek(Optional osd As Boolean = False) As Boolean
  If osd Then 
    mpv_command(["osd-msg", "revert_seek"])
      Else
    mpv_command(["no-osd", "revert_seek"])
  Endif
End


Public Function do_seek(Percentual As String, Optional osd As Boolean = False) As Boolean
  If osd Then 
    mpv_command(["osd-msg", "seek", Percentual, "absolute-percent"])
      Else
    mpv_command(["no-osd", "seek", Percentual, "absolute-percent"])
  Endif
  Raise seeking
End
Public Function do_seek_to(newpos As String, Optional precise As Boolean = False, Optional osd As Boolean = False) As Boolean
  If osd Then 
    mpv_command(["osd-msg", "seek", newpos, "absolute"]) 'fixmempv precise paramters not implemented 
      Else
    mpv_command(["no-osd", "seek", newpos, "absolute"]) 'fixmempv precise paramters not implemented 
  Endif
  Raise seeking
End
Public Function do_seek_by(seconds As String, Optional osd As Boolean = False) As Boolean
  If osd Then 
    mpv_command(["osd-msg", "seek", seconds, "relative"])
      Else
    mpv_command(["no-osd", "seek", seconds, "relative"])
  Endif
  Raise seeking
End

Public Sub _new()
  ClearMediaProperties()
End


Public Function send(data As String, Optional osd As Boolean = True)
  If Not ProcessRunningOvr() Then Return
  If osd Then 
    Try Write #mystream, data & "\n"
      Else
    Try Write #mystream, "no-osd " & data & "\n"
  Endif
End


Private Function merge_collections(c1 As Collection, c2 As Collection) As Collection
  'merge c1 with c2
  'c2 overwrites keys of c1
  Dim out As Collection
  For Each c1
    out.Add(c1.key, c1[c1.key])
  Next
  For Each c2
    out.Add(c2.key, c2[c2.key])
  Next  
End


Private Function deQuote(S As String) As String
  If Left(S) = "\"" And Right(S) = "\"" Then
    Return Right(Left(s, -1), -1)
  Endif
  Return s
End



Private Function what_changes(oldc As Collection, newc As Collection) As Collection
  Dim out As New Collection
  Dim data, k As String
  'given 2 collections, returns a new collection
  'built from changed key values, removed keys,added keys
  
  For Each data In newc
    k = Trim(newc.key)
    If oldc.Exist(k) Then
      If deQuote(oldc[k]) <> deQuote(newc[k]) Then 
        global.myDebug("old option changed", k, oldc[k], newc[k])
        out[k] = newc[k]
      Endif
    Endif

  If Not (oldc.Exist(k)) Then
       global.myDebug("New option added", k, newc[k])
       out[k] = newc[k]
    Endif
  Next

  For Each data In oldc
    k = Trim(oldc.key)
    If Not (newc.Exist(k)) Then
       global.myDebug("old option removed", k, oldc[k])
       out[k] = "|(removed)|"
    Endif
  Next

  Return out
  
End



Private ignore_opts As String[]

Public Sub do_apply(new_opts As Collection) ', Optional only_check_vdpaurb As Boolean = False)
  Dim realtime_opts As String[] = ["af", "af-add", "af-clr", "af-pre", "vf", "vf-add", "vf-clr", "vf-pre"]
  Dim name, data As String
  Dim changed_opts As New Collection
  Dim af_new As String = ""
  Dim vf_new As String = ""
  Dim af_pre_new As String = ""
  Dim vf_pre_new As String = ""

  new_opts = fix_options(new_opts)
  'If only_check_vdpaurb Then Goto rt_options
  
  'see if we need a restart
  'make a list of changed options
  changed_opts = what_changes(mpvoptions, new_opts)

  For Each changed_opts
    name = changed_opts.Key
    data = changed_opts[changed_opts.Key]
    global.myDebug("changed/added/removed option:", name, data)
    If realtime_opts.Find(name) = -1 Then
      If ignore_opts.find(name) = -1 Then
        global.myDebug("option changed/removed/added: " & name, "requires restart")
        do_apply_restart(new_opts)
        Return
      Endif
    Endif
  Next

'ora abbiamo disponibili la lista di nuove opzioni completa di fixed e realtime
'ma ci servono solo le realtime, quindi dobbiamo selezionarle.
global.myDebug("No changed option requires restart, setting realtime properties instead")
'rt_options:
For Each new_opts
  name = new_opts.Key
  data = new_opts[new_opts.Key]
  If realtime_opts.Find(name) >= 0 Then
    Select Case name
      Case "af"
        af_new = data
      Case "af-add"
        If af_new <> "" Then
          af_new = af_new & "," & data
            Else
          af_new = data
        Endif
      Case "af-pre"
        If af_pre_new <> "" Then
          af_pre_new = af_pre_new & "," & data
            Else
          af_pre_new = data
        Endif
      Case "af-clr"
        af_new = ""
        af_pre_new = ""
      Case "vf"
        vf_new = data
      Case "vf-add"
        If vf_new <> "" Then
          vf_new = vf_new & "," & data
            Else
          vf_new = data
        Endif
      Case "vf-pre"
        If vf_pre_new <> "" Then
          vf_pre_new = vf_pre_new & "," & data
            Else
          vf_pre_new = data
        Endif
      Case "vf-clr"
        vf_new = ""
        vf_pre_new = ""
    End Select
  Endif
Next
'Stop
  ' If Left(af_new, "3") = "-1," Then af_new = Right(af_new, -3)
  ' If Left(vf_new, "3") = "-1," Then vf_new = Right(vf_new, -3)

  If Left(af_new) = "," Then af_new = Right(af_new, -1)
  If Left(vf_new) = "," Then vf_new = Right(vf_new, -1)
  If Left(af_pre_new) = "," Then af_new = Right(af_pre_new, -1)
  If Left(vf_pre_new) = "," Then vf_new = Right(vf_pre_new, -1)

  If af_pre_new <> "" Then af_new = af_pre_new & "," & af_new
  If vf_pre_new <> "" Then vf_new = vf_pre_new & "," & vf_new

  If af_new = "|(removed)|" Then af_new = ""
  If vf_new = "|(removed)|" Then vf_new = ""
  set_property_mpv("af", af_new, True)
' ' ' Stop
' ' '       'This part is entirely for reinitialize playback with vdpaurb video filter
' ' '           If vf_new <> "" Then
' ' '             If want_vdpau() Then 
' ' '               'we can't add vdpaurb if we're not hw decoding yet, so:
' ' '                 'clear video filters
' ' '                 set_property_mpv("vf", "", True)
' ' '                 Wait 2
' ' '                 'request hw decoding
' ' '                 set_property_mpv("hwdec", "vdpau", True)
' ' '               vf_new = "vdpaurb," & vf_new
' ' '             Endif
' ' '           Endif

  set_property_mpv("vf", vf_new, True)

  ReturnLabel:
  Return

End



Public Function want_vdpau() As Boolean
  Dim hwdec, hwdec_active, hwdec_detected, vf As String

  hwdec = get_property_mpv("hwdec")
  If hwdec = "no" Then Return 'return if user don't want hwdecoding

  ' hwdec_active = get_property_mpv("hwdec-active") 
  ' If hwdec_active = "yes" Then Return 'return if we're already hwdecoding

  hwdec_detected = get_property_mpv("hwdec-detected")
  If hwdec_detected <> "vdpau" Then Return 'continue only if we're using vdpau

  ' vf = Trim(get_property_mpv("vf"))
  ' If vf <> "(empty)" Then Return 'no need of vdpaurb if no filters are requested

  'If we are here thaen it means:
  'user wants hardware decoding through vdpau
  'hardware decoding is not active for some reason
  '...probably because of video filters.
  Return True

End


Public Sub do_apply_restart(new_opts As Collection)
  Dim name, data, newdata As String
  Dim timepos As String = "0"
  Dim fullpath As String
  Dim restart As Boolean = True
  Dim timerA As Float
  Dim properties_changed_runtime_old_datas As New Collection
  Dim olddata As String = "--------------"
  'Dim only_check_vdpaurb As Boolean = True

  restarting = True

  'store old properties so that we can understand if we succeeded in restoring them
  For Each properties_changed_runtime
    name = properties_changed_runtime.key
    data = get_property_mpv(name, True, 1, True)
    properties_changed_runtime_old_datas[name] = data
  Next
  
  
  If ProcessRunningOvr() Then
    clear_options()
    For Each data In new_opts
      set_option(new_opts.key, data)
    Next
    fullpath = getP("fullpath")
    timepos = get_property_mpv("=time-pos")
    set_option("start", timepos)
    do_play(fullpath,, restart = True)
    Wait 1
    set_property_mpv("options/start", "0")
  Endif

  waitplayback(500)

  'Restore properties changed runtime before the restart
  'more tries are needed because mpv needs to initialize
  'before giving any useful answer.
  'so check if the answer is different from mplayer.unavailable_str
  'and don't spend too much time anyway waiting for the property.
    For Each properties_changed_runtime
        global.myDebug("Try to restore Property:", name, data)
        timerA = Timer()
        Repeat
          name = properties_changed_runtime.key
          If name <> "options/start" Then 'we don't want to restore start property...
            data = properties_changed_runtime[name]
            olddata = Null
            Try olddata = properties_changed_runtime_old_datas[name]
            set_property_mpv(name, data, False)
            Wait 0.01
            newdata = get_property_mpv(name)
          Endif
        Until (newdata <> unavailable_str) Or ((Timer() - TimerA) > 10) Or (newdata = olddata) 'dont spend more than one second per property
        'is it possible that newdata is available but still with an unset value, so, just to be sure, restore it one more time.
        Wait 0.01
        set_property_mpv(name, data, False)
        global.myDebug("Restore property:", name, newdata, data)
    Next

  'do_apply(new_opts, only_check_vdpaurb)

  restarting = False

End


Private man_page As String = ""
Private man_page_lavfi As String = ""

Public Function search_man(search_for As String, Optional lavfi As Boolean = False) As String
  'currently only works for drivers and filters
  Dim st, help_str As String
  Dim s_pos As Integer

  If lavfi Then 'ffmpeg-filters man
    If man_page_lavfi = "" Then
      global.myDebug("Getting ffmpeg-filters man...")
      Shell "man ffmpeg-filters|col -bx" To man_page_lavfi
    Endif
    For Each st In search_term(search_for, lavfi)
      s_pos = InStr(man_page_lavfi, st) 
      If s_pos > 0 Then Return Left(Right(man_page_lavfi, - s_pos), 80 * 300)
      Wait
    Next
      Else 'mpv man

    If man_page = "" Then
      global.myDebug("Getting mpv man...")
      Shell "man mpv|col -bx" To man_page
    Endif
    For Each st In search_term(search_for)
      s_pos = InStr(man_page, st) 
      If s_pos > 0 Then Return Left(Right(man_page, - s_pos), 80 * 100)
      Wait
    Next
  Endif


  Return ""
End



Private Sub search_term(item As String, Optional lavfi As Boolean = False) As String[]
  Dim out As New String[]
  Select Case item
    Case "vdpau"
      Return ["   vdpau (X11 only)"]
    Case "vaapi"
      Return ["Intel VA API video"]
  End Select
  If lavfi Then out.add("  " & Lower(item) & "\n")
  out.add("    " & Lower(item) & "[=" & "")
  out.add("    " & Lower(item) & "=[" & "")
  out.add("    " & Lower(item) & "")
  Return out
End

Public Function filters_available(audio As Boolean) As String[]
  Dim f As String
  Dim out, l As String
  Dim filters As New String[]
  If audio Then 
    f = "af"
      Else
    f = "vf"
  Endif
  Shell executable() & " --" & f & "=help" To out
  For Each l In Split(out, "\n", "", True)
    If l Like "* : *" Then
      filters.Add(Trim(Split(l, ":", "", True)[0]))
    Endif
  Next
  Return filters
End




Public Function get_chapters(Optional cached As Boolean = False) As Chapter[]
  Dim chapter_list As Chapter[]
  Dim aChapter As Chapter
  Dim cCount As Integer = 0
  Dim i As Integer
  Dim properties As String[]

  Try cCount = get_property_mpv("chapter-list/count", (Not cached),, cached)
  If cCount = 0 Then Return
  
  If Not cached Then 'ask chapters to mpv cached parameter is false
    properties = New String[]
    For i = 0 To cCount - 1
      properties.Add("chapter-list/" & i & "/title")
      properties.Add("=chapter-list/" & i & "/time")
    Next
    global.myDebug("asking for chapters...")
    get_properties_mpv(properties, True, False, 5)
    global.myDebug("got chapters (or timeout?)")
  Endif

  chapter_list = New Chapter[]
  For i = 0 To cCount - 1
    aChapter = New Chapter
    aChapter.title = getP("chapter-list/" & i & "/title")
    aChapter.start_time = getP("=chapter-list/" & i & "/time")
    chapter_list.Add(aChapter)
  Next
  Return chapter_list
End


Public Function audio_add(filename As String)
  mpv_command(["audio-add", filename])
End
